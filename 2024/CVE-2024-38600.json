{
  "cve": "CVE-2024-38600",
  "mitre": {
    "cpes": [],
    "created": "2024-06-19T13:45:48.635000+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nALSA: Fix deadlocks with kctl removals at disconnection\n\nIn snd_card_disconnect(), we set card->shutdown flag at the beginning,\ncall callbacks and do sync for card->power_ref_sleep waiters at the\nend.  The callback may delete a kctl element, and this can lead to a\ndeadlock when the device was in the suspended state.  Namely:\n\n* A process waits for the power up at snd_power_ref_and_wait() in\n  snd_ctl_info() or read/write() inside card->controls_rwsem.\n\n* The system gets disconnected meanwhile, and the driver tries to\n  delete a kctl via snd_ctl_remove*(); it tries to take\n  card->controls_rwsem again, but this is already locked by the\n  above.  Since the sleeper isn't woken up, this deadlocks.\n\nAn easy fix is to wake up sleepers before processing the driver\ndisconnect callbacks but right after setting the card->shutdown flag.\nThen all sleepers will abort immediately, and the code flows again.\n\nSo, basically this patch moves the wait_event() call at the right\ntiming.  While we're at it, just to be sure, call wait_event_all()\ninstead of wait_event(), although we don't use exclusive events on\nthis queue for now.",
    "metrics": {
      "cvssV2_0": {},
      "cvssV3_0": {},
      "cvssV3_1": {},
      "cvssV4_0": {}
    },
    "mitre_repo_path": "cves/2024/38xxx/CVE-2024-38600.json",
    "references": [
      "https://git.kernel.org/stable/c/2f103287ef7960854808930499d1181bd0145d68",
      "https://git.kernel.org/stable/c/6b55e879e7bd023a03888fc6c8339edf82f576f4",
      "https://git.kernel.org/stable/c/87988a534d8e12f2e6fc01fe63e6c1925dc5307c",
      "https://git.kernel.org/stable/c/88ce3fe255d58a93624b467af036dc3519f309c7",
      "https://git.kernel.org/stable/c/c2fb439f4f1425a961d20bec818fed2c2d9ef70a",
      "https://git.kernel.org/stable/c/ff80185e7b7b547a0911fcfc8aefc61c3e8304d7"
    ],
    "title": "ALSA: Fix deadlocks with kctl removals at disconnection",
    "updated": "2024-08-02T04:12:26.017000+00:00",
    "vendors": [],
    "weaknesses": []
  },
  "nvd": {
    "cpes": [],
    "created": "2024-06-19T14:15:19.990000+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nALSA: Fix deadlocks with kctl removals at disconnection\n\nIn snd_card_disconnect(), we set card->shutdown flag at the beginning,\ncall callbacks and do sync for card->power_ref_sleep waiters at the\nend.  The callback may delete a kctl element, and this can lead to a\ndeadlock when the device was in the suspended state.  Namely:\n\n* A process waits for the power up at snd_power_ref_and_wait() in\n  snd_ctl_info() or read/write() inside card->controls_rwsem.\n\n* The system gets disconnected meanwhile, and the driver tries to\n  delete a kctl via snd_ctl_remove*(); it tries to take\n  card->controls_rwsem again, but this is already locked by the\n  above.  Since the sleeper isn't woken up, this deadlocks.\n\nAn easy fix is to wake up sleepers before processing the driver\ndisconnect callbacks but right after setting the card->shutdown flag.\nThen all sleepers will abort immediately, and the code flows again.\n\nSo, basically this patch moves the wait_event() call at the right\ntiming.  While we're at it, just to be sure, call wait_event_all()\ninstead of wait_event(), although we don't use exclusive events on\nthis queue for now.",
    "metrics": {
      "cvssV2_0": {},
      "cvssV3_0": {},
      "cvssV3_1": {},
      "cvssV4_0": {}
    },
    "nvd_repo_path": "2024/CVE-2024-38600.json",
    "references": [
      "https://git.kernel.org/stable/c/2f103287ef7960854808930499d1181bd0145d68",
      "https://git.kernel.org/stable/c/6b55e879e7bd023a03888fc6c8339edf82f576f4",
      "https://git.kernel.org/stable/c/87988a534d8e12f2e6fc01fe63e6c1925dc5307c",
      "https://git.kernel.org/stable/c/88ce3fe255d58a93624b467af036dc3519f309c7",
      "https://git.kernel.org/stable/c/c2fb439f4f1425a961d20bec818fed2c2d9ef70a",
      "https://git.kernel.org/stable/c/ff80185e7b7b547a0911fcfc8aefc61c3e8304d7"
    ],
    "title": null,
    "updated": "2024-06-20T12:43:25.663000+00:00",
    "vendors": [],
    "weaknesses": []
  },
  "opencve": {
    "changes": [],
    "cpes": {
      "data": [],
      "providers": []
    },
    "created": {
      "data": "2024-06-19T00:00:00+00:00",
      "provider": "redhat"
    },
    "description": {
      "data": "In the Linux kernel, the following vulnerability has been resolved:\n\nALSA: Fix deadlocks with kctl removals at disconnection\n\nIn snd_card_disconnect(), we set card->shutdown flag at the beginning,\ncall callbacks and do sync for card->power_ref_sleep waiters at the\nend.  The callback may delete a kctl element, and this can lead to a\ndeadlock when the device was in the suspended state.  Namely:\n\n* A process waits for the power up at snd_power_ref_and_wait() in\n  snd_ctl_info() or read/write() inside card->controls_rwsem.\n\n* The system gets disconnected meanwhile, and the driver tries to\n  delete a kctl via snd_ctl_remove*(); it tries to take\n  card->controls_rwsem again, but this is already locked by the\n  above.  Since the sleeper isn't woken up, this deadlocks.\n\nAn easy fix is to wake up sleepers before processing the driver\ndisconnect callbacks but right after setting the card->shutdown flag.\nThen all sleepers will abort immediately, and the code flows again.\n\nSo, basically this patch moves the wait_event() call at the right\ntiming.  While we're at it, just to be sure, call wait_event_all()\ninstead of wait_event(), although we don't use exclusive events on\nthis queue for now.",
      "provider": "mitre"
    },
    "metrics": {
      "cvssV2_0": {
        "data": {},
        "provider": null
      },
      "cvssV3_0": {
        "data": {},
        "provider": null
      },
      "cvssV3_1": {
        "data": {
          "score": 4.4,
          "vector": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H"
        },
        "provider": "redhat"
      },
      "cvssV4_0": {
        "data": {},
        "provider": null
      },
      "kev": {
        "data": {},
        "provider": null
      },
      "ssvc": {
        "data": {},
        "provider": null
      },
      "threat_severity": {
        "data": "Low",
        "provider": "redhat"
      }
    },
    "references": {
      "data": [
        "https://git.kernel.org/stable/c/2f103287ef7960854808930499d1181bd0145d68",
        "https://git.kernel.org/stable/c/6b55e879e7bd023a03888fc6c8339edf82f576f4",
        "https://git.kernel.org/stable/c/87988a534d8e12f2e6fc01fe63e6c1925dc5307c",
        "https://git.kernel.org/stable/c/88ce3fe255d58a93624b467af036dc3519f309c7",
        "https://git.kernel.org/stable/c/c2fb439f4f1425a961d20bec818fed2c2d9ef70a",
        "https://git.kernel.org/stable/c/ff80185e7b7b547a0911fcfc8aefc61c3e8304d7",
        "https://lore.kernel.org/linux-cve-announce/2024061957-CVE-2024-38600-aa7e@gregkh/T",
        "https://nvd.nist.gov/vuln/detail/CVE-2024-38600",
        "https://www.cve.org/CVERecord?id=CVE-2024-38600"
      ],
      "providers": [
        "mitre",
        "nvd",
        "redhat"
      ]
    },
    "title": {
      "data": "ALSA: Fix deadlocks with kctl removals at disconnection",
      "provider": "mitre"
    },
    "updated": {
      "data": "2024-08-02T04:12:26.017000+00:00",
      "provider": "mitre"
    },
    "vendors": {
      "data": [],
      "providers": []
    },
    "weaknesses": {
      "data": [
        "CWE-833"
      ],
      "providers": [
        "redhat"
      ]
    }
  },
  "redhat": {
    "cpes": [],
    "created": "2024-06-19T00:00:00+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved:\nALSA: Fix deadlocks with kctl removals at disconnection\nIn snd_card_disconnect(), we set card->shutdown flag at the beginning,\ncall callbacks and do sync for card->power_ref_sleep waiters at the\nend.  The callback may delete a kctl element, and this can lead to a\ndeadlock when the device was in the suspended state.  Namely:\n* A process waits for the power up at snd_power_ref_and_wait() in\nsnd_ctl_info() or read/write() inside card->controls_rwsem.\n* The system gets disconnected meanwhile, and the driver tries to\ndelete a kctl via snd_ctl_remove*(); it tries to take\ncard->controls_rwsem again, but this is already locked by the\nabove.  Since the sleeper isn't woken up, this deadlocks.\nAn easy fix is to wake up sleepers before processing the driver\ndisconnect callbacks but right after setting the card->shutdown flag.\nThen all sleepers will abort immediately, and the code flows again.\nSo, basically this patch moves the wait_event() call at the right\ntiming.  While we're at it, just to be sure, call wait_event_all()\ninstead of wait_event(), although we don't use exclusive events on\nthis queue for now.",
    "metrics": {
      "cvssV2_0": {},
      "cvssV3_0": {},
      "cvssV3_1": {
        "score": 4.4,
        "vector": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H"
      },
      "threat_severity": "Low"
    },
    "redhat_repo_path": "2024/CVE-2024-38600.json",
    "references": [
      "https://lore.kernel.org/linux-cve-announce/2024061957-CVE-2024-38600-aa7e@gregkh/T",
      "https://nvd.nist.gov/vuln/detail/CVE-2024-38600",
      "https://www.cve.org/CVERecord?id=CVE-2024-38600"
    ],
    "title": "kernel: ALSA: Fix deadlocks with kctl removals at disconnection",
    "updated": "2024-06-19T00:00:00+00:00",
    "vendors": [],
    "weaknesses": [
      "CWE-833"
    ]
  }
}