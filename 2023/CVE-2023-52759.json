{
  "cve": "CVE-2023-52759",
  "mitre": {
    "cpes": [],
    "created": "2024-05-21T15:30:45.773000+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ngfs2: ignore negated quota changes\n\nWhen lots of quota changes are made, there may be cases in which an\ninode's quota information is increased and then decreased, such as when\nblocks are added to a file, then deleted from it. If the timing is\nright, function do_qc can add pending quota changes to a transaction,\nthen later, another call to do_qc can negate those changes, resulting\nin a net gain of 0. The quota_change information is recorded in the qc\nbuffer (and qd element of the inode as well). The buffer is added to the\ntransaction by the first call to do_qc, but a subsequent call changes\nthe value from non-zero back to zero. At that point it's too late to\nremove the buffer_head from the transaction. Later, when the quota sync\ncode is called, the zero-change qd element is discovered and flagged as\nan assert warning. If the fs is mounted with errors=panic, the kernel\nwill panic.\n\nThis is usually seen when files are truncated and the quota changes are\nnegated by punch_hole/truncate which uses gfs2_quota_hold and\ngfs2_quota_unhold rather than block allocations that use gfs2_quota_lock\nand gfs2_quota_unlock which automatically do quota sync.\n\nThis patch solves the problem by adding a check to qd_check_sync such\nthat net-zero quota changes already added to the transaction are no\nlonger deemed necessary to be synced, and skipped.\n\nIn this case references are taken for the qd and the slot from do_qc\nso those need to be put. The normal sequence of events for a normal\nnon-zero quota change is as follows:\n\ngfs2_quota_change\n   do_qc\n      qd_hold\n      slot_hold\n\nLater, when the changes are to be synced:\n\ngfs2_quota_sync\n   qd_fish\n      qd_check_sync\n         gets qd ref via lockref_get_not_dead\n   do_sync\n      do_qc(QC_SYNC)\n         qd_put\n\t    lockref_put_or_lock\n   qd_unlock\n      qd_put\n         lockref_put_or_lock\n\nIn the net-zero change case, we add a check to qd_check_sync so it puts\nthe qd and slot references acquired in gfs2_quota_change and skip the\nunneeded sync.",
    "metrics": {
      "cvssV2_0": {},
      "cvssV3_0": {},
      "cvssV3_1": {},
      "cvssV4_0": {}
    },
    "mitre_repo_path": "cves/2023/52xxx/CVE-2023-52759.json",
    "references": [
      "https://git.kernel.org/stable/c/119565e566f91ff3588ffcd5812f0c8061586c6b",
      "https://git.kernel.org/stable/c/1c28dace66015b675a343b89b0c87abbfda05ff4",
      "https://git.kernel.org/stable/c/212f112fe5e90e98eb8d48585682880dae139f4c",
      "https://git.kernel.org/stable/c/2a054b87a1b799b391e578597a42ee6e57a987ae",
      "https://git.kernel.org/stable/c/2bb42a27a92ff3984c9fa5fbe128eced3ea693f2",
      "https://git.kernel.org/stable/c/4c6a08125f2249531ec01783a5f4317d7342add5",
      "https://git.kernel.org/stable/c/53fc16c1ad84f5467ec24341670b63aa759335d3",
      "https://git.kernel.org/stable/c/5bfda356e903633d16ae1bac1ee38364e12628a3",
      "https://git.kernel.org/stable/c/b4deec69fe32b58dc5fb4ace52456ece85b75561"
    ],
    "title": "gfs2: ignore negated quota changes",
    "updated": "2024-08-02T23:11:35.888000+00:00",
    "vendors": [],
    "weaknesses": []
  },
  "nvd": {
    "cpes": [],
    "created": "2024-05-21T16:15:15.330000+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ngfs2: ignore negated quota changes\n\nWhen lots of quota changes are made, there may be cases in which an\ninode's quota information is increased and then decreased, such as when\nblocks are added to a file, then deleted from it. If the timing is\nright, function do_qc can add pending quota changes to a transaction,\nthen later, another call to do_qc can negate those changes, resulting\nin a net gain of 0. The quota_change information is recorded in the qc\nbuffer (and qd element of the inode as well). The buffer is added to the\ntransaction by the first call to do_qc, but a subsequent call changes\nthe value from non-zero back to zero. At that point it's too late to\nremove the buffer_head from the transaction. Later, when the quota sync\ncode is called, the zero-change qd element is discovered and flagged as\nan assert warning. If the fs is mounted with errors=panic, the kernel\nwill panic.\n\nThis is usually seen when files are truncated and the quota changes are\nnegated by punch_hole/truncate which uses gfs2_quota_hold and\ngfs2_quota_unhold rather than block allocations that use gfs2_quota_lock\nand gfs2_quota_unlock which automatically do quota sync.\n\nThis patch solves the problem by adding a check to qd_check_sync such\nthat net-zero quota changes already added to the transaction are no\nlonger deemed necessary to be synced, and skipped.\n\nIn this case references are taken for the qd and the slot from do_qc\nso those need to be put. The normal sequence of events for a normal\nnon-zero quota change is as follows:\n\ngfs2_quota_change\n   do_qc\n      qd_hold\n      slot_hold\n\nLater, when the changes are to be synced:\n\ngfs2_quota_sync\n   qd_fish\n      qd_check_sync\n         gets qd ref via lockref_get_not_dead\n   do_sync\n      do_qc(QC_SYNC)\n         qd_put\n\t    lockref_put_or_lock\n   qd_unlock\n      qd_put\n         lockref_put_or_lock\n\nIn the net-zero change case, we add a check to qd_check_sync so it puts\nthe qd and slot references acquired in gfs2_quota_change and skip the\nunneeded sync.",
    "metrics": {
      "cvssV2_0": {},
      "cvssV3_0": {},
      "cvssV3_1": {},
      "cvssV4_0": {}
    },
    "nvd_repo_path": "2023/CVE-2023-52759.json",
    "references": [
      "https://git.kernel.org/stable/c/119565e566f91ff3588ffcd5812f0c8061586c6b",
      "https://git.kernel.org/stable/c/1c28dace66015b675a343b89b0c87abbfda05ff4",
      "https://git.kernel.org/stable/c/212f112fe5e90e98eb8d48585682880dae139f4c",
      "https://git.kernel.org/stable/c/2a054b87a1b799b391e578597a42ee6e57a987ae",
      "https://git.kernel.org/stable/c/2bb42a27a92ff3984c9fa5fbe128eced3ea693f2",
      "https://git.kernel.org/stable/c/4c6a08125f2249531ec01783a5f4317d7342add5",
      "https://git.kernel.org/stable/c/53fc16c1ad84f5467ec24341670b63aa759335d3",
      "https://git.kernel.org/stable/c/5bfda356e903633d16ae1bac1ee38364e12628a3",
      "https://git.kernel.org/stable/c/b4deec69fe32b58dc5fb4ace52456ece85b75561"
    ],
    "title": null,
    "updated": "2024-05-21T16:53:56.550000+00:00",
    "vendors": [],
    "weaknesses": []
  },
  "opencve": {
    "changes": [],
    "cpes": {
      "data": [],
      "providers": []
    },
    "created": {
      "data": "2024-05-21T00:00:00+00:00",
      "provider": "redhat"
    },
    "description": {
      "data": "In the Linux kernel, the following vulnerability has been resolved:\n\ngfs2: ignore negated quota changes\n\nWhen lots of quota changes are made, there may be cases in which an\ninode's quota information is increased and then decreased, such as when\nblocks are added to a file, then deleted from it. If the timing is\nright, function do_qc can add pending quota changes to a transaction,\nthen later, another call to do_qc can negate those changes, resulting\nin a net gain of 0. The quota_change information is recorded in the qc\nbuffer (and qd element of the inode as well). The buffer is added to the\ntransaction by the first call to do_qc, but a subsequent call changes\nthe value from non-zero back to zero. At that point it's too late to\nremove the buffer_head from the transaction. Later, when the quota sync\ncode is called, the zero-change qd element is discovered and flagged as\nan assert warning. If the fs is mounted with errors=panic, the kernel\nwill panic.\n\nThis is usually seen when files are truncated and the quota changes are\nnegated by punch_hole/truncate which uses gfs2_quota_hold and\ngfs2_quota_unhold rather than block allocations that use gfs2_quota_lock\nand gfs2_quota_unlock which automatically do quota sync.\n\nThis patch solves the problem by adding a check to qd_check_sync such\nthat net-zero quota changes already added to the transaction are no\nlonger deemed necessary to be synced, and skipped.\n\nIn this case references are taken for the qd and the slot from do_qc\nso those need to be put. The normal sequence of events for a normal\nnon-zero quota change is as follows:\n\ngfs2_quota_change\n   do_qc\n      qd_hold\n      slot_hold\n\nLater, when the changes are to be synced:\n\ngfs2_quota_sync\n   qd_fish\n      qd_check_sync\n         gets qd ref via lockref_get_not_dead\n   do_sync\n      do_qc(QC_SYNC)\n         qd_put\n\t    lockref_put_or_lock\n   qd_unlock\n      qd_put\n         lockref_put_or_lock\n\nIn the net-zero change case, we add a check to qd_check_sync so it puts\nthe qd and slot references acquired in gfs2_quota_change and skip the\nunneeded sync.",
      "provider": "mitre"
    },
    "metrics": {
      "cvssV2_0": {
        "data": {},
        "provider": null
      },
      "cvssV3_0": {
        "data": {},
        "provider": null
      },
      "cvssV3_1": {
        "data": {
          "score": 5.5,
          "vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        },
        "provider": "redhat"
      },
      "cvssV4_0": {
        "data": {},
        "provider": null
      },
      "kev": {
        "data": {},
        "provider": null
      },
      "ssvc": {
        "data": {},
        "provider": null
      },
      "threat_severity": {
        "data": "Moderate",
        "provider": "redhat"
      }
    },
    "references": {
      "data": [
        "https://git.kernel.org/stable/c/119565e566f91ff3588ffcd5812f0c8061586c6b",
        "https://git.kernel.org/stable/c/1c28dace66015b675a343b89b0c87abbfda05ff4",
        "https://git.kernel.org/stable/c/212f112fe5e90e98eb8d48585682880dae139f4c",
        "https://git.kernel.org/stable/c/2a054b87a1b799b391e578597a42ee6e57a987ae",
        "https://git.kernel.org/stable/c/2bb42a27a92ff3984c9fa5fbe128eced3ea693f2",
        "https://git.kernel.org/stable/c/4c6a08125f2249531ec01783a5f4317d7342add5",
        "https://git.kernel.org/stable/c/53fc16c1ad84f5467ec24341670b63aa759335d3",
        "https://git.kernel.org/stable/c/5bfda356e903633d16ae1bac1ee38364e12628a3",
        "https://git.kernel.org/stable/c/b4deec69fe32b58dc5fb4ace52456ece85b75561",
        "https://lore.kernel.org/linux-cve-announce/2024052147-CVE-2023-52759-0e9f@gregkh/T",
        "https://nvd.nist.gov/vuln/detail/CVE-2023-52759",
        "https://www.cve.org/CVERecord?id=CVE-2023-52759"
      ],
      "providers": [
        "mitre",
        "nvd",
        "redhat",
        "vulnrichment"
      ]
    },
    "title": {
      "data": "gfs2: ignore negated quota changes",
      "provider": "mitre"
    },
    "updated": {
      "data": "2024-08-02T23:11:35.888000+00:00",
      "provider": "mitre"
    },
    "vendors": {
      "data": [],
      "providers": []
    },
    "weaknesses": {
      "data": [
        "CWE-99"
      ],
      "providers": [
        "redhat"
      ]
    }
  },
  "redhat": {
    "cpes": [],
    "created": "2024-05-21T00:00:00+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved:\ngfs2: ignore negated quota changes\nWhen lots of quota changes are made, there may be cases in which an\ninode's quota information is increased and then decreased, such as when\nblocks are added to a file, then deleted from it. If the timing is\nright, function do_qc can add pending quota changes to a transaction,\nthen later, another call to do_qc can negate those changes, resulting\nin a net gain of 0. The quota_change information is recorded in the qc\nbuffer (and qd element of the inode as well). The buffer is added to the\ntransaction by the first call to do_qc, but a subsequent call changes\nthe value from non-zero back to zero. At that point it's too late to\nremove the buffer_head from the transaction. Later, when the quota sync\ncode is called, the zero-change qd element is discovered and flagged as\nan assert warning. If the fs is mounted with errors=panic, the kernel\nwill panic.\nThis is usually seen when files are truncated and the quota changes are\nnegated by punch_hole/truncate which uses gfs2_quota_hold and\ngfs2_quota_unhold rather than block allocations that use gfs2_quota_lock\nand gfs2_quota_unlock which automatically do quota sync.\nThis patch solves the problem by adding a check to qd_check_sync such\nthat net-zero quota changes already added to the transaction are no\nlonger deemed necessary to be synced, and skipped.\nIn this case references are taken for the qd and the slot from do_qc\nso those need to be put. The normal sequence of events for a normal\nnon-zero quota change is as follows:\ngfs2_quota_change\ndo_qc\nqd_hold\nslot_hold\nLater, when the changes are to be synced:\ngfs2_quota_sync\nqd_fish\nqd_check_sync\ngets qd ref via lockref_get_not_dead\ndo_sync\ndo_qc(QC_SYNC)\nqd_put\nlockref_put_or_lock\nqd_unlock\nqd_put\nlockref_put_or_lock\nIn the net-zero change case, we add a check to qd_check_sync so it puts\nthe qd and slot references acquired in gfs2_quota_change and skip the\nunneeded sync.",
    "metrics": {
      "cvssV2_0": {},
      "cvssV3_0": {},
      "cvssV3_1": {
        "score": 5.5,
        "vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
      },
      "threat_severity": "Moderate"
    },
    "redhat_repo_path": "2023/CVE-2023-52759.json",
    "references": [
      "https://lore.kernel.org/linux-cve-announce/2024052147-CVE-2023-52759-0e9f@gregkh/T",
      "https://nvd.nist.gov/vuln/detail/CVE-2023-52759",
      "https://www.cve.org/CVERecord?id=CVE-2023-52759"
    ],
    "title": "kernel: gfs2: ignore negated quota changes",
    "updated": "2024-05-21T00:00:00+00:00",
    "vendors": [],
    "weaknesses": [
      "CWE-99"
    ]
  },
  "vulnrichment": {
    "cpes": [],
    "created": "2024-05-21T15:30:45.773000+00:00",
    "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ngfs2: ignore negated quota changes\n\nWhen lots of quota changes are made, there may be cases in which an\ninode's quota information is increased and then decreased, such as when\nblocks are added to a file, then deleted from it. If the timing is\nright, function do_qc can add pending quota changes to a transaction,\nthen later, another call to do_qc can negate those changes, resulting\nin a net gain of 0. The quota_change information is recorded in the qc\nbuffer (and qd element of the inode as well). The buffer is added to the\ntransaction by the first call to do_qc, but a subsequent call changes\nthe value from non-zero back to zero. At that point it's too late to\nremove the buffer_head from the transaction. Later, when the quota sync\ncode is called, the zero-change qd element is discovered and flagged as\nan assert warning. If the fs is mounted with errors=panic, the kernel\nwill panic.\n\nThis is usually seen when files are truncated and the quota changes are\nnegated by punch_hole/truncate which uses gfs2_quota_hold and\ngfs2_quota_unhold rather than block allocations that use gfs2_quota_lock\nand gfs2_quota_unlock which automatically do quota sync.\n\nThis patch solves the problem by adding a check to qd_check_sync such\nthat net-zero quota changes already added to the transaction are no\nlonger deemed necessary to be synced, and skipped.\n\nIn this case references are taken for the qd and the slot from do_qc\nso those need to be put. The normal sequence of events for a normal\nnon-zero quota change is as follows:\n\ngfs2_quota_change\n   do_qc\n      qd_hold\n      slot_hold\n\nLater, when the changes are to be synced:\n\ngfs2_quota_sync\n   qd_fish\n      qd_check_sync\n         gets qd ref via lockref_get_not_dead\n   do_sync\n      do_qc(QC_SYNC)\n         qd_put\n\t    lockref_put_or_lock\n   qd_unlock\n      qd_put\n         lockref_put_or_lock\n\nIn the net-zero change case, we add a check to qd_check_sync so it puts\nthe qd and slot references acquired in gfs2_quota_change and skip the\nunneeded sync.",
    "metrics": {
      "cvssV2_0": {},
      "cvssV3_0": {},
      "cvssV3_1": {},
      "cvssV4_0": {},
      "kev": {},
      "ssvc": {}
    },
    "references": [
      "https://git.kernel.org/stable/c/119565e566f91ff3588ffcd5812f0c8061586c6b",
      "https://git.kernel.org/stable/c/1c28dace66015b675a343b89b0c87abbfda05ff4",
      "https://git.kernel.org/stable/c/212f112fe5e90e98eb8d48585682880dae139f4c",
      "https://git.kernel.org/stable/c/2a054b87a1b799b391e578597a42ee6e57a987ae",
      "https://git.kernel.org/stable/c/2bb42a27a92ff3984c9fa5fbe128eced3ea693f2",
      "https://git.kernel.org/stable/c/4c6a08125f2249531ec01783a5f4317d7342add5",
      "https://git.kernel.org/stable/c/53fc16c1ad84f5467ec24341670b63aa759335d3",
      "https://git.kernel.org/stable/c/5bfda356e903633d16ae1bac1ee38364e12628a3",
      "https://git.kernel.org/stable/c/b4deec69fe32b58dc5fb4ace52456ece85b75561"
    ],
    "title": "gfs2: ignore negated quota changes",
    "updated": "2024-08-02T23:11:35.888000+00:00",
    "vendors": [],
    "vulnrichment_repo_path": "2023/52xxx/CVE-2023-52759.json",
    "weaknesses": []
  }
}